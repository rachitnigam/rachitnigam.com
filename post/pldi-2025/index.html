<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="author" content="Rachit Nigam">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <title> Reflecting on PLDI 2025 |  Rachit Nigam </title>
  

  <link rel="icon" href=https://people.csail.mit.edu/rachit/flower.svg type="image/svg+xml">

  <link rel="stylesheet" href=https://people.csail.mit.edu/rachit/css/normalize.css>
  <link rel="stylesheet" href=https://people.csail.mit.edu/rachit/css/default.css>
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous"/>

  <!-- Load source code pro -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://people.csail.mit.edu/rachit/post/atom.xml">
  
</head>

<body>
  
  <header>
    <h1 class="name"><a class="unstyled-link" href=https://people.csail.mit.edu/rachit>Rachit Nigam</a></h1>
    <nav>
      <a class="unstyled-link nav-item" href=https://people.csail.mit.edu/rachit/#publications>Publications</a>
      <a class="unstyled-link nav-item" href=https://people.csail.mit.edu/rachit/#posts>Posts</a>
      <a class="unstyled-link nav-item" href=https://people.csail.mit.edu/rachit/files/resume.pdf>CV</a>
    </nav>
  </header>
  
  <section class="section">
    <div class="container">
      
<div class="post-header">
<h1 class="title">
  Reflecting on PLDI 2025
</h1>
<div class="date">
New prof attends his first conference
</div>
<p class="date">July 02, 2025</p>
</div>

<div class="post">
<p>PLDI is one of the marquee programming languages conference and one my favorite ones to attend. The number of domains that PL are working in and bringing ideas to is frankly overwhelming and inspiring. I had a bunch of interesting conversations that incited new ideas and perspectives for me.</p>
<h2 id="for-the-masses-or-for-the-flops">For the Masses or for the FLOPs?</h2>
<p>Building and programming heterogenous systems has quickly become one of <em>the key problems</em> being tackled by the systems community. For the PL community, this should present tons of interesting work on defining programming models for emerging accelerators (GPUs, TPUs) and programming large systems that use them. Given this, I was surprised by the lack of papers tackling these problems.</p>
<p>After several long conversations with other conference attendees, I came up with the following framing. Programming languages research has two models of impact: building for the masses or building for the FLOPs (floating-point operations).
A <a rel="noopener nofollow noreferrer" target="_blank" href="https://probablydance.com/2024/10/07/initial-cuda-performance-lessons/"><em>vast majority</em> of the FLOPs</a> in the world today come from specialized hardware like GPUs and TPUs.
These accelerators generally use highly specialized programming models like CUDA or high-level languages like PyTorch.
On the other hand, a <em>vast majority</em> of programmers <a rel="noopener nofollow noreferrer" target="_blank" href="https://www.tiobe.com/tiobe-index/">use general-purpose languages</a> like Python or JavaScript.</p>
<p>As a PL researcher, this poses a problem: you can work on building programming systems that enable more people to effectively interface with computers, or you could build better interfaces to a vast majority of the computation in the world.
I think the current iteration of the PLDI community focuses on the former problem–of building better programming systems for the most number of people–while conferences like ASPLOS publish a lot more of the work on the latter kinds of problems.<span style="white-space:nowrap">
<label for="sn-1"
       class="margin-toggle sidenote-number">
</label>
</span>
<input type="checkbox"
       id="sn-1"
       class="margin-toggle"/>
<span class="sidenote">
For example, the <a rel="noopener nofollow noreferrer" target="_blank" href="https://dl.acm.org/doi/10.1145/3620665.3640366">PyTorch 2</a> paper was published at ASPLOS ’24.
</span>
<p>Like most distinctions, I don’t think this is a black-and-white divide but I did find this to be a useful lens to look through.</p></p>
<h2 id="tools-for-language-evolution">Tools for Language Evolution</h2>
<p>Turning to general-purpose languages, the new <a rel="noopener nofollow noreferrer" target="_blank" href="https://pldi25.sigplan.org/home/rpls-2025">RPLS workshop</a> and Sukyong Ryu’s keynote highlighted the need for tools for language evolution.
There has been a lot of work in the community on building tools that help specify formal semantics of languages and automatically generate tools like interpreters, symbolic verifiers, etc.
Instead of trying to use general-purpose semantics specification tools like the <a rel="noopener nofollow noreferrer" target="_blank" href="https://kframework.org/">K framework</a>, Sukyong’s group has developed language specific tools: ESMeta for JavaScript, and SpecTec for WASM and worked hard to integrate into the community’s workflow.
For example, the JavaScript community already had an English-language specification for operations like <a rel="noopener nofollow noreferrer" target="_blank" href="https://tc39.es/ecma262/#sec-numeric-types-number-add">addition</a> that are written with a precise pseudocode language.
It would be a drastic change of norms (and a huge waste) to throw out these specifications.
<a rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/es-meta/esmeta">ESMeta</a> provides a formal specification language to describe JavaScript (or, as it is officially called, ECMAScript) and automatically generates the same English-language documentation.
This means that the community can move towards a formal, single source of truth model for defining the language and keeping it up-to-date.</p>
<p>These kinds of single-source of truth language specifications seem to only be growing in importance.
The WASM community adopted the SpecTec project (also from Sukyong’s group), ARM defines the ISA semantics using the <a rel="noopener nofollow noreferrer" target="_blank" href="https://developer.arm.com/Architectures/Architecture%20Specification%20Language">architecture specification language (ASL)</a> and the <a rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/rems-project/sail">SAIL architecture specification language</a> has been successfully used to define the semantics of ISAs like ARM-A, x86, IBM Power, and CHERI.</p>
<h2 id="formal-verification-looms-large">Formal Verification Looms Large</h2>
<p>Formal verification of systems, languages, and semantics remains one of the primary focuses of PLDI.
Two out of the six <a rel="noopener nofollow noreferrer" target="_blank" href="https://pldi25.sigplan.org/program/program-pldi-2025/?badge=Distinguished%20Paper">distinguished papers</a> focused on formal verification of some form and Leo de Moura gave a keynote on the <a rel="noopener nofollow noreferrer" target="_blank" href="https://lean-lang.org/">Lean project</a>.
The talk went over the wide impact Lean has had over the mathematics and the software engineering community.
Terrance Tao’s ongoing interest in Lean for formalizing mathematical theorems and use with AI assistants has also <a rel="noopener nofollow noreferrer" target="_blank" href="https://www.quantamagazine.org/lean-computer-program-confirms-peter-scholze-proof-20210728/">made headlines</a>.
There were two projects that I particularly found interesting:</p>
<ul>
<li>The <a rel="noopener nofollow noreferrer" target="_blank" href="https://leanprover-community.github.io/mathlib-overview.html"><code>mathlib</code> project</a> which has slowly accumulated theorems and proofs from algebra, geometry, and analysis. The project provides a large number of building blocks for anyone interested in writing sophisticated mathematical proofs (like Terrance Tao’s proof of the <a rel="noopener nofollow noreferrer" target="_blank" href="https://terrytao.wordpress.com/2023/11/18/formalizing-the-proof-of-pfr-in-lean4-using-blueprint-a-short-tour/">PFR conjecture</a>).</li>
<li>The <a rel="noopener nofollow noreferrer" target="_blank" href="https://pirlea.net/papers/veil-cav25.pdf">Veil Framework</a> by folks at NUS which provides a domain-specific language verifying distributed algorithms. The cool thing about Veil is that because it is embedded within Lean, it can provide both <em>automatic</em> and <em>deductive</em> verification. The former uses SMT solver integration to perform proof search while the latter uses the Lean proof assistant to generate proofs through tactics. Furthermore, because Lean has extensive metaprogramming support, Veil programs actually look more like Alloy or TLA+ programs than like other Leans.</li>
</ul>
<p>These two projects, to me, provide an existence proof for the potential of designing large-scale hardware-software verification stacks within Lean.
For example, think of a system that takes proofs about computations on fully homomorphically encrypted data and connects them all the way down to the hardware while allowing domain experts to use abstractions they’re familiar and comfortable with!</p>
<h2 id="papers">Papers</h2>
<p>The main conference has several parallel tracks so I couldn’t see all the talks I wanted to but here is a collection of talks I found interesting:</p>
<ul>
<li><a rel="noopener nofollow noreferrer" target="_blank" href="https://dl.acm.org/doi/10.1145/3729331">Making Concurrent Hardware Verification Sequential</a>: Normally, when thinking about the behavior of a processor, we like to think of a <em>sequential implementation</em>–an interpreter that run each instruction one at a time–as the ideal behavior of the processor. Pipelining, speculation, out-of-order execution all must be shown to be <em>refinement</em> of (i.e., admitting fewer behaviors than) this sequential implementation. This feels like a pretty reasonable model and exactly how I thought of processors. However, this paper shows that it is <em>not actually possible</em> to connect purely sequential implementations to more complex processors! The crux of the problem is that a real processor might, for example, have multiple memory requests in-flight before the first one returns, which is a behavior that the sequential implementation <em>cannot</em> exhibit but a pipelined one might. I find this result pretty staggering and am very interested in diving into the details.</li>
<li><a rel="noopener nofollow noreferrer" target="_blank" href="https://arxiv.org/pdf/2501.14550">Bean: A Language for Backward Error Analysis</a>: The talk presented a type system to quantify the <em>backward error</em> present in a program due to floating-point errors (compared to a corresponding real-valued computation). I found this to be a <em>really cool</em> combination of deep theory work (to make the notion of compositional error analysis work) and application focused ideas (error analysis is done very manually and seems to be very tedious). The paper presents a limited language with quite a few restrictions (which are justified and analyzed by the theory) but to me, the interesting part was that <em>this is even possible at all</em>. The talk is well worth a watch when it shows up on the SIGPLAN channel.</li>
<li><a rel="noopener nofollow noreferrer" target="_blank" href="https://theory.stanford.edu/~aiken/publications/papers/pldi25.pdf">Task-Based Tensor Computations on Modern GPUs</a>: One of the only talks about GPU programming. Beyond the research contributions, I found the talk to be a pretty lucid description of the current programming mode for GPUs (which is kind of insane and cool). The crux of the problem is that the newest NVIDIA GPUs have an asynchronous execution interface for the tensor cores (circuits that perform matrix-multiply) and the processor cores (<em>simultaneous multi-processors</em>) need to find work to do while the tensor cores are doing their thing. The standard SIMT programming model makes it hard to find and do said work so the task-based approach makes a lot more sense.</li>
<li><a rel="noopener nofollow noreferrer" target="_blank" href="https://publish.illinois.edu/hpvm-project/files/2025/04/Towards_Automatic_Generation_of_Efficient_Retargetable_Semantic_Driven_Optimizations-10.pdf">MISAAL: Synthesis-Based Automatic Generation of Efficient and Retargetable Semantics-Driven Optimizations</a>. MISAAL continues in the line of work from Vikram Adve’s group on automatically synthesizing compilers from ISA specifications. The work has a lot of moving pieces so I’ll leave the details to the paper but one thing I found to be interesting was that the authors parsed the pseudocode language used by different ISA vendors to generate specifications for ISA instructions! This is a pretty good example where specification languages like ASL can go beyond explaining existing languages and enable novel research.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>The golden age of computer architecture continues and with it, heterogeneity remains one of the most interesting and challenging programming problems. I continue to think that the toolset developed by the PL community is extremely well-suited to address these problems and I’m excited to see what folks build next!</p>

</div>


    </div>
  </section>

<footer>
  &copy;&nbsp;2021 Rachit Nigam &middot; Built using <a href="https://www.getzola.org/">Zola</a>
</footer>
</body>

</html>
